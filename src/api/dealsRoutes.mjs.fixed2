/**
 * API routes for deal operations
 * This file provides endpoints to manage deals in PostgreSQL
 */

import express from 'express';
import jwt from 'jsonwebtoken';
import pg from 'pg';
import dotenv from 'dotenv';

dotenv.config();

const router = express.Router();

// Database connection
const pool = new pg.Pool({
  host: process.env.VITE_DB_HOST || 'localhost',
  port: parseInt(process.env.VITE_DB_PORT || '5432', 10),
  database: process.env.VITE_DB_NAME || 'asp_crm',
  user: process.env.VITE_DB_USER || 'postgres',
  password: process.env.VITE_DB_PASSWORD || 'vedant21',  // Use the correct password
  ssl: process.env.VITE_DB_SSL === 'true' ? { rejectUnauthorized: false } : false
});

// Log database connection info for debugging
console.log('Database connection parameters:', {
  host: process.env.VITE_DB_HOST || 'localhost',
  port: parseInt(process.env.VITE_DB_PORT || '5432', 10),
  database: process.env.VITE_DB_NAME || 'asp_crm',
  user: process.env.VITE_DB_USER || 'postgres',
  passwordProvided: process.env.VITE_DB_PASSWORD ? 'Yes' : 'No',
  ssl: process.env.VITE_DB_SSL === 'true'
});

// Test database connection on startup
pool.query('SELECT NOW()').then(result => {
  console.log('✓ PostgreSQL connection test successful:', result.rows[0].now);
}).catch(error => {
  console.error('✗ PostgreSQL connection test failed:', error);
});

// JWT secret from environment variables
const JWT_SECRET = process.env.VITE_JWT_SECRET || 'your-secure-jwt-secret-key-change-in-production';

// Authentication middleware
const authenticateToken = async (req, res, next) => {
  try {
    // Get token from authorization header
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    // Verify token
    const decoded = jwt.verify(token, JWT_SECRET);
    
    // Add user data to request
    req.user = decoded;
    next();
  } catch (error) {
    console.error('Token verification error:', error);
    return res.status(403).json({ error: 'Invalid token' });
  }
};

// Apply authentication middleware to all routes
router.use(authenticateToken);

/**
 * Get all deals
 */
router.get('/', async (req, res) => {
  let client;
  try {
    client = await pool.connect();
    console.log('Client connected for GET /deals');
    
    // Join deals with customers to get customer information
    const query = `
      SELECT 
        d.id,
        d.deal_id,
        d.customer_id,
        d.lead_id,
        d.status,
        d.amount,
        d.notes,
        d.assigned_to,
        d.created_at,
        d.updated_at,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.company as customer_company,
        c.address as customer_address,
        c.designation as customer_designation,
        u.name as assigned_to_name,
        u.display_name as assigned_to_display_name
      FROM deals d
      LEFT JOIN customers c ON d.customer_id = c.customer_id
      LEFT JOIN users u ON d.assigned_to = u.uid
      ORDER BY d.created_at DESC
    `;
    
    console.log('Executing query...');
    const result = await client.query(query);
    console.log(`Query returned ${result.rows.length} deals`);
    
    // Transform data to match the Deal type
    const deals = result.rows.map(row => ({
      id: row.deal_id,
      customerId: row.customer_id,
      leadId: row.lead_id || '',
      title: row.notes ? `Deal for ${row.customer_name || 'Customer'}` : row.deal_id, // Create a reasonable title
      description: row.notes || '', // Using notes as description
      customer: {
        name: row.customer_name || 'Unknown Customer',
        email: row.customer_email || '',
        phone: row.customer_phone || '',
        company: row.customer_company || '',
        address: row.customer_address || '',
        designation: row.customer_designation || ''
      },
      value: parseFloat(row.amount) || 0, // Use amount field instead of value
      probability: 0, // Default since probability field doesn't exist
      stage: row.status, // Use status field as stage
      assignedTo: row.assigned_to || '',
      assignedToName: row.assigned_to_display_name || row.assigned_to_name || '',
      expectedCloseDate: new Date().toISOString(), // Default since field doesn't exist
      notes: row.notes || '',
      createdAt: row.created_at || new Date().toISOString(),
      updatedAt: row.updated_at || new Date().toISOString()
    }));
    
    res.status(200).json(deals);
  } catch (error) {
    console.error('Error fetching deals:', error);
    res.status(500).json({ error: 'Failed to fetch deals: ' + error.message });
  } finally {
    if (client) {
      client.release();
      console.log('Client released');
    }
  }
});

/**
 * Get deal by ID
 */
router.get('/:id', async (req, res) => {
  let client;
  try {
    const { id } = req.params;
    client = await pool.connect();
    console.log(`Getting deal ${id}`);
    
    // Join deals with customers to get customer information
    const query = `
      SELECT 
        d.id,
        d.deal_id,
        d.customer_id,
        d.lead_id,
        d.status,
        d.amount,
        d.notes,
        d.assigned_to,
        d.created_at,
        d.updated_at,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.company as customer_company,
        c.address as customer_address,
        c.designation as customer_designation,
        u.name as assigned_to_name,
        u.display_name as assigned_to_display_name
      FROM deals d
      LEFT JOIN customers c ON d.customer_id = c.customer_id
      LEFT JOIN users u ON d.assigned_to = u.uid
      WHERE d.deal_id = $1
    `;
    
    const result = await client.query(query, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Deal not found' });
    }
    
    const row = result.rows[0];
    
    // Transform data to match the Deal type
    const deal = {
      id: row.deal_id,
      customerId: row.customer_id,
      leadId: row.lead_id || '',
      title: row.notes ? `Deal for ${row.customer_name || 'Customer'}` : row.deal_id,
      description: row.notes || '',
      customer: {
        name: row.customer_name || 'Unknown Customer',
        email: row.customer_email || '',
        phone: row.customer_phone || '',
        company: row.customer_company || '',
        address: row.customer_address || '',
        designation: row.customer_designation || ''
      },
      value: parseFloat(row.amount) || 0,
      probability: 50,
      stage: row.status,
      assignedTo: row.assigned_to || '',
      assignedToName: row.assigned_to_display_name || row.assigned_to_name || '',
      createdBy: '',
      expectedCloseDate: new Date().toISOString(),
      notes: row.notes || '',
      createdAt: row.created_at || new Date().toISOString(),
      updatedAt: row.updated_at || new Date().toISOString()
    };
    
    res.status(200).json(deal);
  } catch (error) {
    console.error('Error fetching deal by ID:', error);
    res.status(500).json({ error: 'Failed to fetch deal: ' + error.message });
  } finally {
    if (client) {
      client.release();
    }
  }
});

/**
 * Create a new deal
 */
router.post('/', async (req, res) => {
  let client;
  try {
    client = await pool.connect();
    await client.query('BEGIN');
    
    const {
      title,
      description,
      leadId,
      customerId,
      customer,
      value,
      probability,
      stage,
      assignedTo,
      expectedCloseDate,
      notes,
      createdBy
    } = req.body;
    
    console.log('Creating deal with data:', { customerId, leadId, stage, value, assignedTo });
    
    // Generate a new unique ID for the deal
    const dealId = `deal-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      // Insert the deal
    await client.query(
      `INSERT INTO deals 
       (deal_id, lead_id, customer_id, status, amount, notes, assigned_to) 
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [dealId, leadId, customerId, stage, value, notes, assignedTo]
    );
    
    await client.query('COMMIT');
    console.log('Deal created successfully:', dealId);
    
    // Return the created deal
    const createdDeal = {
      id: dealId,
      customerId,
      leadId,
      title,
      description,
      customer,
      value,
      probability,
      stage,
      assignedTo,
      expectedCloseDate,
      notes,
      createdBy,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    res.status(201).json(createdDeal);
  } catch (error) {
    if (client) await client.query('ROLLBACK');
    console.error('Error creating deal:', error);
    res.status(500).json({ error: 'Failed to create deal: ' + error.message });
  } finally {
    if (client) {
      client.release();
    }
  }
});

/**
 * Update deal stage
 */
router.put('/:id/stage', async (req, res) => {
  let client;
  try {
    const { id } = req.params;
    const { stage } = req.body;
    
    console.log(`Updating deal ${id} stage to ${stage}`);
    
    client = await pool.connect();
    
    // Update the deal stage (stored as status field in DB)
    await client.query(
      'UPDATE deals SET status = $1, updated_at = NOW() WHERE deal_id = $2',
      [stage, id]
    );
    
    // Get the updated deal
    const query = `
      SELECT 
        d.deal_id,
        d.customer_id,
        d.status,
        d.amount,
        d.notes,
        d.assigned_to,
        d.lead_id,
        d.created_at,
        d.updated_at,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone,
        c.company as customer_company,
        c.address as customer_address,
        c.designation as customer_designation,
        u.name as assigned_to_name,
        u.display_name as assigned_to_display_name
      FROM deals d
      LEFT JOIN customers c ON d.customer_id = c.customer_id
      LEFT JOIN users u ON d.assigned_to = u.uid
      WHERE d.deal_id = $1
    `;
    
    const result = await client.query(query, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Deal not found' });
    }
    
    const row = result.rows[0];
    
    // Transform data to match the Deal type
    const deal = {
      id: row.deal_id,
      customerId: row.customer_id,
      leadId: row.lead_id || '',
      title: row.notes ? `Deal for ${row.customer_name || 'Customer'}` : row.deal_id,
      description: row.notes || '',
      customer: {
        name: row.customer_name || 'Unknown Customer',
        email: row.customer_email || '',
        phone: row.customer_phone || '',
        company: row.company_name || row.customer_company || '',
        address: row.customer_address || '',
        designation: row.customer_designation || ''
      },
      value: parseFloat(row.amount) || 0,
      probability: 50,
      stage: row.status,
      assignedTo: row.assigned_to || '',
      assignedToName: row.assigned_to_display_name || row.assigned_to_name || '',
      expectedCloseDate: new Date().toISOString(),
      notes: row.notes || '',
      createdAt: row.created_at || new Date().toISOString(),
      updatedAt: row.updated_at || new Date().toISOString()
    };
    
    console.log('Deal stage updated successfully');
    res.status(200).json(deal);
  } catch (error) {
    console.error('Error updating deal stage:', error);
    res.status(500).json({ error: 'Failed to update deal stage: ' + error.message });
  } finally {
    if (client) {
      client.release();
    }
  }
});

export default router;
